# 타임 변화(Type Casting)과 오버플로·정밀도
**변수(Variable)** 는 **데이터를 저장할 수 있는 이름 붙은 상자**라고 생각하면 돼요.  
그런데 상자의 크기가 다르면 값이 그대로 들어가지 않을 수 있겠죠?  
예를 들어, 작은 컵의 물을 큰 컵에 옮기는 건 쉽지만, 큰 컵의 물을 작은 컵에 다 담기는 어렵습니다.  
이게 바로 **타입 변환(Type Casting)** 이에요.

---
## 개념 설명
### 자동 형변환(묵시적 변환, Widening Casting)
- 작은 타입 -> 큰 타입으로 자동 변환
- 데이터 손실 없음
- 예: `int -> long`, `int -> double`
### 명시적 형변환(강제 변환, Narrowing Casting)
- 큰 타입 -> 작은 타입으로 강제로 변환
- 데이터 손실 가능성 있음
- `(타입)` 캐스팅 연산자를 사용
- 예: `double -> int` (소수점 버려짐)
### 오버플로(Overflow)
- 타입의 최대 범위를 넘으면 값이 반대쪽으로 튐
- 예: `byte b = 127; b++; // b = -128`;
### 정밀도(Precision) 문제
- `float`, `double`은 근사값이라서 정확히 떨어지지 않을 수 있음
- 금액 계산에는 `BigDecimal` 사용 권장

---
## 코드 예시
```java
public class CastingExample {  
    public static void main(String[] args){  
        // 자동 형변환(Widening Casting)  
        int a = 10;  
        double b = a;  // int -> double 자동 변환  
        System.out.println("자동 형변환: " + b);  
  
        // 명시적 형변환 (Narrowing Casting)
        double c = 9.7;  
        int d = (int) c;  // double -> int 강제 변환 (소수점 손실)  
        System.out.println("명시적 형변환: " + d);  
  
        // 오버플로  
        byte e = 127;  
        e++;  
        System.out.println("오버플로: " + e);  
  
        // 정밀도 문제  
        double x = 0.1;  
        double y = 0.2;  
        System.out.println("0.1 + 0.2 = " + (x + y));  
    }  
}
```

---
## 코드 해설
- `double b = a;` -> `int`는 `double`보다 작으므로 자동 변환
- `int d = (int) c;` -> `9.7`에서 소수점이 잘려 `9` 저장.
- `byte e = 127; e++;` -> `byte`의 최대값(127)을 넘으면 `-128`로 돌아감.
- `0.1 + 0.2` -> 이진 부동소수점 표현 한계 때문에 `0.30000000000000004` 출력

---
## 모범 사례 / 팁
- 큰 타입 -> 작은 타입 변환은 **데이터 손실 가능** -> 꼭 필요한 경우만
- 금전, 정밀 게산 -> `BigDecimal` 사용
- 오버플로는 컴파일러가 잡아주지 않음 -> 값 범위를 항상 체크
- 변수 타입은 의도에 맞게 선언
	- 예: 나이(`int`), 키(`double`), 금액(`BigDecimal`)

